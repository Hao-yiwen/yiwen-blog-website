# kotlin中的协成

Kotlin 协程是 Kotlin 语言对异步编程和并发的一种解决方案，旨在简化异步操作的复杂性，提高代码的可读性和可维护性。协程提供了一种在不阻塞线程的情况下执行长时间运行操作（如网络请求、数据库操作等）的能力，使得开发异步代码就像开发同步代码一样简单。

## 关键特性

-   轻量级：协程在运行时几乎不需要额外的资源，非常轻量。你可以在单个线程上并发运行数千个协程而不会造成性能下降。
-   非阻塞：协程通过挂起操作而不是阻塞，来等待长时间运行的操作完成，从而释放线程去执行其他任务。这一点对于 UI 程序尤其重要，可以保持应用响应用户操作。
-   结构化并发：协程强调结构化并发，意味着协程的启动和销毁都受到严格管理，避免了资源泄露和许多并发相关的问题。

## 基本概念

-   协程构建器：如 launch 和 async，用于在协程作用域中启动新的协程。launch 用于执行不需要返回结果的协程，而 async 用于需要返回结果的协程，它返回一个 Deferred 对象，可以通过 await() 方法获取结果。
-   挂起函数：通过 suspend 关键字标记的函数。挂起函数可以在不阻塞当前线程的情况下挂起和恢复协程的执行。挂起函数只能在协程或其他挂起函数内部调用。
-   协程作用域：协程需要在指定的作用域中执行，这有助于管理协程的生命周期和结构化并发。CoroutineScope 可以用来创建新的作用域，而 GlobalScope 是全局作用域，生命周期与应用程序相同。
-   调度器：决定协程执行的线程或线程池。常见的调度器包括 Dispatchers.Main（在 UI 线程中执行）、Dispatchers.IO（针对 IO 任务优化的线程池）和 Dispatchers.Default（针对计算密集型任务优化的线程池）。(Dispatchers.Config不常用，因为可能运行在任意线程)

## 使用示例

```kt
import kotlinx.coroutines.*

fun main() = runBlocking { // 创建一个顶层协程，阻塞当前线程直到所有子协程完成
    launch { // 在 runBlocking 作用域内启动一个新的协程
        delay(1000L) // 非阻塞地等待 1 秒（挂起协程）
        println("World!")
    }
    println("Hello,") // 主线程继续执行，而不会等待
}
```
