# Flow

Kotlin Flows 是 Kotlin 为处理异步数据流（asynchronous stream）引入的一套 API。这些 API 是协程（coroutines）的一部分，专门用于处理时间上分散的一系列数据。Flows 允许你以非阻塞的方式工作，使得在多个线程之间传递数据变得简单且安全。

## 核心特性

-   非阻塞：Flows 构建在 Kotlin 协程之上，提供了一种非阻塞的方式来处理异步数据流。
-   冷流：Flows 是按需生成的（即仅当订阅者开始收集时，数据才开始流动），这与热流（始终处于活动状态并广播数据给所有订阅者）形成对比。
-   组合操作符：提供了丰富的操作符，如 map、filter、take 等，允许对数据流进行变换和组合。
-   背压管理：虽然 Flows 本身不直接处理背压问题（当生产数据的速率超过消费者处理速率时发生的问题），但是它可以通过协程的挂起来间接实现背压管理。

## 使用场景

-   网络请求：使用 Flows 处理异步的网络请求响应。
-   数据库操作：监听数据库变化并响应。
-   实时数据更新：如股票价格、游戏得分等实时数据的更新。
-   用户界面事件处理：监听和响应用户界面事件，如点击、滑动等。

## 示例代码

```kt
fun main() {
    runBlocking {
        launch {
            for (k in 1..3) {
                println("I'm not blocked $k")
                delay(100)
            }
        }
        simple().collect { value -> println(value) }
    }
}

fun simple(): Flow<Int> = flow{
    for (k in 1..3) {
        delay(100)
        emit(k)
    }
}
```

## 冷流和热流

### 冷流（Cold Flow）

-   被动的：冷流不会自己开始产生数据，除非有收集器开始收集它们（collect 方法被调用）。换句话说，数据的生产是由消费者驱动的。
-   按需生产：每次收集器开始收集时，冷流都会从头开始生成数据。这意味着每个收集器都会获得独立的数据序列。
-   例子：flow { emit(1) } 是一个简单的冷流示例，它只在有收集操作时产生数据。

### 热流（Hot Flow）

-   主动的：热流开始产生数据的时刻不依赖于是否有收集器存在。它们可能在后台独立运行，与收集器的存在与否无关。
-   共享状态或事件：热流的数据由所有收集器共享。这意味着，一个热流的当前值是由最近发射的值表示的，当新的收集器开始收集时，它可能会错过之前发射的值。
-   例子：StateFlow 和 SharedFlow 是热流的例子。它们可以用来表示应用的状态或者是应用中发生的事件。

### 主要区别

-   启动方式：冷流的启动是被收集器触发的，而热流的启动通常是独立于收集器的。
-   数据共享：冷流为每个收集器独立产生数据序列，而热流的数据由所有收集器共享。

### 使用场景：

-   冷流：适用于数据流是按需生成并且对每个收集器都是独立的场景，如网络请求、数据库查询。
-   热流：适用于需要共享状态或事件的场景，如 UI 状态更新、实时消息。

## StateFlow

StateFlow 是一种特殊的 Flow，用于表示随时间变化的状态。它具有以下特点：

-   始终保持当前状态值：StateFlow 保持一个当前的状态值，任何时候都可以访问。当你开始收集一个 StateFlow 时，它会立即发射当前的状态值，这使得它非常适合用于 UI 状态的管理。
-   状态更新：你可以更新 StateFlow 的状态，所有的观察者（收集器）都会接收到新的状态值。
-   热流特性：与其他热流一样，StateFlow 的生命周期独立于它的收集器。一旦 StateFlow 的值被更新，所有的活跃收集器都会接收到最新的值，即使这些值在收集器开始收集之前就已经发射了。

## 为什么 Flow 是冷的？

因为 Flow 的设计初衷是为了方便地在协程中表示异步数据流。通过将数据流的生成延迟到收集阶段，Flow 提供了更大的灵活性和控制，使其能够更容易地表达复杂的数据处理操作，同时保持轻量级和响应性。

Flow 的这种冷流特性，使其适合于表示数据的动态变化，例如网络请求、数据库查询等操作，这些操作只有在实际需要数据时才会被触发和执行。

尽管 Flow 是冷流，Kotlin 提供了将冷流转换为热流的机制，如 StateFlow 和 SharedFlow，这两种类型的流可以保持状态或者共享发射的数据给多个收集器，而不需要重新执行数据生成逻辑。
