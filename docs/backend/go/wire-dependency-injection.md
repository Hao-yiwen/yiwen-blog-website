---
sidebar_position: 21
title: Wire 依赖注入指南
tags: [go, golang, wire, 依赖注入, dependency-injection, 代码生成]
---

# Google Wire 指南：Go 语言的编译时依赖注入

## 1. 简介：什么是 Wire？

**Wire** 是 Google 开源的一个用于 Go 语言的依赖注入工具。与 Uber 的 `dig` 或 Facebook 的 `inject` 等基于**反射（Reflection）**的运行时（Runtime）注入工具不同，Wire 采用的是**代码生成（Code Generation）**的方式。

### 核心优势

- **编译时安全（Compile-time Safety）：** 如果依赖关系缺失或类型错误，代码无法编译通过。这意味着在这个阶段就能发现错误，而不是在程序运行时崩溃。
- **无运行时开销：** 它是生成普通的 Go 代码，没有反射带来的性能损耗。
- **代码可读性：** 生成的代码清晰易懂，就是普通的构造函数调用链，易于调试。

---

## 2. 核心概念

在使用 Wire 之前，需要理解两个基本概念：

### A. Provider (提供者)

Provider 就是一个普通的 Go 函数，它"提供"一个组件。通常就是我们写的构造函数（Constructor）。

- **输入：** 依赖项。
- **输出：** 产生的对象（以及可选的 error）。

```go
// 这是一个 Provider
// 它依赖 Message，返回 Greeter
func NewGreeter(m Message) Greeter {
    return Greeter{Message: m}
}
```

### B. Injector (注入者)

Injector 是一个由 `wire` 命令行工具生成的函数。它负责按顺序调用 Providers，把整个依赖图（Dependency Graph）构建出来。

---

## 3. 快速上手

### 步骤 1: 安装 Wire

你需要安装 Wire 的命令行工具：

```bash
go install github.com/google/wire/cmd/wire@latest
```

### 步骤 2: 准备业务代码 (Providers)

假设我们有一个简单的应用：`Event` 依赖 `Greeter`，`Greeter` 依赖 `Message`。

```go
package main

import "fmt"

// 1. Message 组件
type Message string

func NewMessage() Message {
    return Message("Hello, Wire!")
}

// 2. Greeter 组件 (依赖 Message)
type Greeter struct {
    Message Message
}

func NewGreeter(m Message) Greeter {
    return Greeter{Message: m}
}

func (g Greeter) Greet() string {
    return string(g.Message)
}

// 3. Event 组件 (依赖 Greeter)
type Event struct {
    Greeter Greeter
}

func NewEvent(g Greeter) Event {
    return Event{Greeter: g}
}

func (e Event) Start() {
    fmt.Println(e.Greeter.Greet())
}
```

### 步骤 3: 编写 Injector 签名

创建一个名为 `wire.go` 的文件（文件名不强制，但推荐）。在这个文件中，我们定义 Injector 的函数签名。

> **注意：** 文件头部必须加上 build tag，确保这个文件不会被包含在最终的二进制编译中。

```go
//go:build wireinject
// +build wireinject

package main

import "github.com/google/wire"

// InitializeEvent 是我们的 Injector
func InitializeEvent() (Event, error) {
    // wire.Build 告诉 Wire 使用哪些 Provider 来构建 Event
    wire.Build(NewMessage, NewGreeter, NewEvent)
    return Event{}, nil // 返回值只是为了满足编译器，实际会被生成的代码替换
}
```

### 步骤 4: 生成代码

在终端运行：

```bash
wire
```

Wire 会扫描当前目录，找到 `wire.go`，并生成一个名为 `wire_gen.go` 的文件。

**生成的 `wire_gen.go` 大致如下（自动生成，无需手写）：**

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

func InitializeEvent() (Event, error) {
    message := NewMessage()
    greeter := NewGreeter(message)
    event := NewEvent(greeter)
    return event, nil
}
```

### 步骤 5: 在 main 中使用

现在你可以像调用普通函数一样调用生成的 Injector：

```go
func main() {
    event, err := InitializeEvent()
    if err != nil {
        panic(err)
    }
    event.Start()
}
```

---

## 4. 高级特性

### Provider Set (集合)

当组件很多时，一个个列出 `NewFunction` 很麻烦。可以将相关的 Providers 组合成一个 `ProviderSet`。通常用于按照业务模块组织代码。

```go
// var 定义集合
var SuperSet = wire.NewSet(NewMessage, NewGreeter, NewEvent)

func InitializeEvent() (Event, error) {
    wire.Build(SuperSet) // 直接使用集合
    return Event{}, nil
}
```

### 接口绑定 (Binding Interfaces)

如果构造函数返回的是结构体，但你需要注入接口，使用 `wire.Bind`。

```go
type Fooer interface {
    Foo()
}

type MyFooer struct{}

func NewMyFooer() *MyFooer {
    return &MyFooer{}
}

// 告诉 Wire: 当需要 Fooer 接口时，使用 *MyFooer 类型
var Set = wire.NewSet(
    NewMyFooer,
    wire.Bind(new(Fooer), new(*MyFooer)),
)
```

### 结构体构造 (Struct Providers)

有时候你不想写 `New...` 函数，只想直接填充结构体的字段。可以使用 `wire.Struct`。

```go
type User struct {
    Name string
    Age  int
}

// "*" 代表注入所有字段
var UserSet = wire.NewSet(
    wire.Struct(new(User), "*"),
)
```

### 清理函数 (Cleanup)

如果 Provider 返回一个清理函数（例如关闭文件句柄、数据库连接），Wire 能够识别并将其串联起来。

Provider 签名：

```go
func NewDB() (*sql.DB, func(), error) {
    db, _ := sql.Open(...)
    cleanup := func() { db.Close() }
    return db, cleanup, nil
}
```

生成的 Injector 也会返回一个汇总的 cleanup 函数，供你在 `main` 中 `defer` 调用。

---

## 5. 常见问题与最佳实践

| 特性 | 说明 |
| --- | --- |
| **错误处理** | 如果 Provider 返回 error，Wire 生成的代码会自动检查 `if err != nil` 并向上传递。 |
| **单例模式** | 在同一次 Injector 调用（scope）中，同一个类型的 Provider 只会被调用一次（默认表现为单例）。 |
| **循环依赖** | Wire 不支持循环依赖，检测到后会在生成代码时报错。这是设计特性，迫使你优化架构。 |

### 什么时候使用 Wire？

- **推荐：** 大型项目，组件依赖关系复杂（深度超过3层），需要严格的类型检查。
- **不推荐：** 极简单的脚本，或者极其强调动态插拔插件的系统。

---

## 6. 示例代码

完整示例代码请参考：[go-wire 示例](https://github.com/Hao-yiwen/go-examples/tree/master/go-wire)

---

## 总结

Wire 通过将依赖注入的逻辑从**运行时**提前到了**编译时**，极大地提高了 Go 项目的健壮性。它虽然多了一个代码生成步骤，但换来的是编译期的安全保障和易于阅读的初始化代码。
